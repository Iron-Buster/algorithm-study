package com.fqh.分组循环;

/**
 * @author ikun
 * @version v1.0.0
 * @since 2024/1/19 23:10
 **/
public class LC_2464 {

//    2464. 有效分割中的最少子数组数目
//            中等
//    相关标签
//            提示
//    给定一个整数数组 nums。
//
//    如果要将整数数组 nums 拆分为 子数组 后是 有效的，则必须满足:
//
//    每个子数组的第一个和最后一个元素的最大公约数 大于 1，且
//    nums 的每个元素只属于一个子数组。
//    返回 nums 的 有效 子数组拆分中的 最少 子数组数目。如果不能进行有效的子数组拆分，则返回 -1。
//
//    注意:
//
//    两个数的 最大公约数 是能整除两个数的最大正整数。
//    子数组 是数组中连续的非空部分。
//
//
//    示例 1:
//
//    输入: nums = [2,6,3,4,3]
//    输出: 2
//    解释: 我们可以通过以下方式创建一个有效的分割: [2,6] | [3,4,3].
//            - 第一个子数组的起始元素是 2，结束元素是 6。它们的最大公约数是 2，大于 1。
//            - 第二个子数组的起始元素是 3，结束元素是 3。它们的最大公约数是 3，大于 1。
//    可以证明，2 是我们在有效分割中可以获得的最少子数组数。

//    public int validSubarraySplit(int[] nums) {
//        return f(nums);
//    }
//
//    // 分组循环
//    public int f(int[] a) {
//        int n = a.length;
//        int i = 0;
//        int ans = 0;
//        while (i < n) {
//            int st = i;
//            for (++i; i < n && gcd(a[st], a[i]) > 1; i++);
//            ans++;
//        }
//        return ans;
//    }
//
//    // 最大公约数
//    static int gcd(int a, int b) {
//        while (a != 0) {
//            int temp = a;
//            a = b % a;
//            b = temp;
//        }
//        return b;
//    }
}
